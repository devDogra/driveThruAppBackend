customers make orders from the app
emps see made orders on the app
they prepare the order
and when they deliver it to the drive thru window they mark it as delivered after the
customer ***PAYS IN CASH***

** admin have FULL ACCESS to all routes and functionalities **

------------------------------------------------
    all these api calls have a lot of repetition even for diff resources....
    for eg: there's always a valid id check and stuff and the same
    resps being sent, the only diff being the name of the resource
    in the resp msgs 
------------------------------------------------

[x] cant make/create an empty order (with no menu items). have the api disallow the creation of this (disallowing in the Order model)
[x] add to orders who made that order
[x] menu items in orders' items [] must be references, because if they'renot
    then the user could create an order and have the price be changed
    (using references via ObjectIds)

[x] orders api
    [x] create order (customers can, admin can)
    [x] delete order (customers can cancel orders within 5 mins of making them)
                    (potentially employees could also do this)
                    (but have to keep track of cancelled/deleted orders...???? so should we soft delete ie just mark em as cancelled?)
    [x] put/patch order (both partial updates) (customers can within 5 mins of making them)
                        (emps could potentially do this too after approval from cust, but that's for later)
    [x] get order(customers, emp both can)
    [x] get all orders (by user id optional)

[x] menu items api
    [x] GET (customer, emp, admin)
        GET /menuItems/ => all items
        GET /menuItems/:id
    [x] POST (admin; only admin can add new items to the menu)
        [x] cant create same item number items
    [x] PUT (also handles partial updates) (admin) note: mongoose ignores updates to fields not defined in the schema
    [x] DELETE (admin)
            
[x] users api
    [x] GET (customer, emp, admin)
    [x] PUT/PATCH (customer [can edit his own details])
    [x] DELETE (customer, admin)
    [x] POST (**handled in registration**)

[ ] add authentication
we'll use the user's 'email' field as the username
    [ ] add the password field to the user model/schema
    [ ] add validation to email to ensure that it's a valid email
    [ ] add validation to password to ensure that the password is atleast 8 characters long
        - but cant add it on the schema because that will store the **HASHED** password, so we have to validate the password length from the api
    [ ] at the register/ route's controller, hash the received password and store THAT in the DB
    [ ] make a /login or /authenticate route which receieves a { email, password } and sends back an access token with the payload { email } 
    and also a refresh token with the payload { email }
    the acc token must have a short expiry (keep it 1 min) for dev 
    the refresh token must have a longer expiry (hours)
    [ ] make a /refreshToken route that takes in a refresh toen, verifies it and if it's valid then it sends back an access token 
    [ ] PROTECT ROUTES 
        [ ] make middleware that verifies if a jwt is valid (name it verifyJWT or ensureAuthenticated [ I'm liking the first name more and more] ) the middleware must take a req, get the access token sent as a cookie in the req, chck if it's valid, and if it is, allow the ececution of the next() middlewares. if it's not valid then  then it must send back a response indicating so. 


    
[ ] add user roles
[ ] protect routes acesss by role