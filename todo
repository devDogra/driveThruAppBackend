/* -------------------------------------------------------------------------- */
testing reminder => access tokens have an expiry of 30s
/* -------------------------------------------------------------------------- */

customers make orders from the app
emps see made orders on the app
they prepare the order
and when they deliver it to the drive thru window they mark it as delivered after the
customer ***PAYS IN CASH***

** admin have FULL ACCESS to all routes and functionalities **

------------------------------------------------
    all these api calls have a lot of repetition even for diff resources....
    for eg: there's always a valid id check and stuff and the same
    resps being sent, the only diff being the name of the resource
    in the resp msgs 
------------------------------------------------

[x] cant make/create an empty order (with no menu items). have the api disallow the creation of this (disallowing in the Order model)
[x] add to orders who made that order
[x] menu items in orders' items [] must be references, because if they'renot
    then the user could create an order and have the price be changed
    (using references via ObjectIds)

[x] orders api
    [x] create order (customers can, admin can)
    [x] delete order (customers can cancel orders within 5 mins of making them)
                    (potentially employees could also do this)
                    (but have to keep track of cancelled/deleted orders...???? so should we soft delete ie just mark em as cancelled?)
    [x] put/patch order (both partial updates) (customers can within 5 mins of making them)
                        (emps could potentially do this too after approval from cust, but that's for later)
    [x] get order(customers, emp both can)
    [x] get all orders (by user id optional)

[x] menu items api
    [x] GET (customer, emp, admin)
        GET /menuItems/ => all items
        GET /menuItems/:id
    [x] POST (admin; only admin can add new items to the menu)
        [x] cant create same item number items
    [x] PUT (also handles partial updates) (admin) note: mongoose ignores updates to fields not defined in the schema
    [x] DELETE (admin)
            
[x] users api
    [x] GET (customer, emp, admin)
    [x] PUT/PATCH (customer [can edit his own details])
    [x] DELETE (customer, admin)
    [x] POST (**handled in registration**)

[ ] add authentication
we'll use the user's 'phone' field as the username
    [x] add the password field to the user model/schema
    [ ] [bypass for now]  add validation to email to ensure that it's a valid email (bypassing for now bc not using email as the username)
    [x] add validation to password  
        - but cant add it on the schema because that will store the **HASHED** password, so we have to validate the password length from the api
        [x] ensure that the password is atleast 8 characters long
    [x] at the register/ route's controller, hash the received password and store THAT in the DB
    [x] make a /login or /authenticate route which receieves a { email (NOT EMAIL, PHONE NUMBER!!!!), password } and sends back an access token with the payload { email } 
    and also a refresh token with the payload { email }
    the acc token must have a short expiry (keep it 1 min) for dev 
    the refresh token must have a longer expiry (hours)
    [x] make a /refreshToken route that takes in a refresh toen, verifies it and if it's valid then it sends back an access token 
    [ ] PROTECT ROUTES 
        [x] make middleware that verifies if a jwt is valid (name it verifyJWT or ensureAuthenticated [ I'm liking the first name more and more] ) the middleware must take a req, get the access token sent as a cookie---NOT COOKIE---!!!! (REQ's Authorization header) (a in the req, chck if it's valid, and if it is, allow the ececution of the next() middlewares. if it's not valid then  then it must send back a response indicating so. 
        [ ] add user roles to config, make an admin accnt. 
        when the user sends a jwt, verify it and if succ, get the associated user's role from the DB from it. if the role matches the allowedRoles in the middleware, then OK 
    [ ] make a /logout route
        [ ] the client app's responsibility is to delete the access token, but our server app will make sure that on req sent to /logout route the httpOnly cookie containing the refresh token is cleared
    [ ] ****store the RT associated with a particular user in his DB record
        - we want to be able to have a list of all issued RTs so we can revoke em at any point
        - ***will require modifications to the logincontroller, logoutcontroller (store reftok, del reftok)
    [ ] IMPLEMENT ROLES
        [x] make roles obj in config
        [x] have verifyJwt set req.role, make a middleware allowRoles(r1, r2..) that checks whether req.role is r1 or r2 or... etc and if it is. next(), and if it isn't, throw error
        [ ] make an admin accnt (cant be created via api)
        [ ] give only the admin account the ABILITY to ELEVATE a Customer account role (default role) to the employeee role 
        [ ] customers can PUT (update) their OWN account, but cant elevate their own role 
        [ ] employees cant update their own account. only admin can.  the emps will have to get permission from the admin and have HIM update their accunt
        [ ] customers can create orders
        [ ] customers can delete/update orders within 5 mins of creating them 
        [ ] customers can GET their OWN orders 
        [ ] customers can edit their own acc details with the exception of:
            - phone
            - role
        [ ] emps can update orders (status only i.e pending to delivered or cancelled)
        [ ] emps 
    [ ] PROTECT ROUTES BY ROLE 


    
[ ] add user roles
[ ] protect routes acesss by role

/* --------------------- user roles and what they can do -------------------- */

roles -----------------
|                     |
customer              emp 
                       |
                      mgr 
                       |
                      admin

the customer role is a bit diff from the emp, 
but the mgr can do everything the emp can and some more 
the admin can do everything the mgr can and some more

creating orders 
    customers 
    emps
    manager
    admin
updating orders
    customers
        - can create/make ORDERS 
        - can update orders' items ordered, not status
        - can get all of their OWN orders
        - can delete their OWN account
        - NOT ALLOWED: can delete orders. would waste resurces
        - can edit their account details a bit 
            - phone number
            - name 
            - password
            - email
        
        
    emps
        - NOT ALLOWED: can fully update orders (too much security risk, so NO)
        - can update order status (pending -> delivered / cancelled etc)
        - NOT ALLOWED: can delete orders ("hey employee, delete my order please") (no, bc then deliver order then delete it and keep the money)
        - can get all orders
        - can edit their account details a bit 
            - phone number
            - name 
            - password
            - email
    manager         
        - all emp priviliges, plus:
        - can update the menu (menuitems)
    admin:
        - all mgr priviliges, plus:
        - can elevate roles (cust -> emp -> mgr) and demote them 
        - can delete users (accounts) (the admin owns the app and thus has the right to cntrol which accounts can exist on it) 

        